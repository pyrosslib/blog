{
  
    
        "post0": {
            "title": "Simulating testing and quarantine",
            "content": "%matplotlib inline import numpy as np import pyross import matplotlib.pyplot as plt #from matplotlib import rc; rc(&#39;text&#39;, usetex=True) . The SIR model with quarantine . Below you will find the model-specification dictionary for the SIR model with quarantined states . model_spec = { &quot;classes&quot; : [&quot;S&quot;, &quot;I&quot;], &quot;S&quot; : { &quot;infection&quot; : [ [&quot;I&quot;, &quot;-beta&quot;] ], }, &quot;I&quot; : { &quot;linear&quot; : [ [&quot;I&quot;, &quot;-gamma&quot;] ], &quot;infection&quot; : [ [&quot;I&quot;, &quot;beta&quot;] ], }, # S I R &quot;test_pos&quot; : [ &quot;p_falsepos&quot;, &quot;p_truepos&quot;, &quot;p_falsepos&quot;] , &quot;test_freq&quot; : [ &quot;pi_RS&quot;, &quot;pi_I&quot;, &quot;pi_RS&quot;] } parameters = { &#39;beta&#39; : 0.1, &#39;gamma&#39; : 0.1, &#39;p_falsepos&#39; : 0.01, &#39;p_truepos&#39; : 0.9, &#39;pi_RS&#39; : 0.1, &#39;pi_I&#39; : 1 } . from IPython.display import Image Image(&#39;SIRQ.png&#39;) . This corresponds to . $$ begin{aligned} dot{S}_i &amp; = - beta sum_j C_{ij} frac{I_j}{N_j} S_i - tau_S S_i; &amp; dot{S}^Q_i &amp; = tau_S S_i dot{I}_i &amp; = beta sum_j C_{ij} frac{I_j}{N_j} S_i - gamma I_i - tau_I I_i; &amp; dot{I}^Q_i &amp; =- gamma I_i^Q+ tau_I I_i dot{R}_i &amp; = gamma I_i- tau_R R_i; &amp; dot{R}^Q_i &amp; = gamma I^Q_i+ tau_R R_i; end{aligned} $$Each of the classes, S, I and R, have a quarantined version, SQ, IQ and RQ. The dynamics within the quarantined states is the same as for the un-quarantined states, but there are no infection terms (assuming perfect quarantine). Individuals are quarantined upon testing positive, hence the total number $N^Q=S^Q+I^Q+R^Q$ would be the reported number of confirmed cases. . The transition rates $ tau_S$, $ tau_I$, $ tau_R$ for irreversible transitions to the quarantined states are dependent on time and on other variables. They are determined by the overall testing rate $ tau_{tot}(t)$ and the parameters specified in &quot;test_pos&quot; and &quot;test_prob&quot; (ordered such that they match to S, I and R). . &quot;test_pos&quot; specifies the probability $ kappa_S$, $ kappa_I$, $ kappa_R$ that a test performed on an individual of a given class is positive. For classes $R$ and $S$, this is the conditional probability of false positives, for class $I$ the conditional probability of a true positive . | &quot;test_freq&quot; characterises the frequency $ pi_S$, $ pi_I$, $ pi_R$ of tests in a given class. The absolute values of these values does not matter, only their relative magnitudes. If we consider symptomatic testing and set $ pi_I=1$, then $ pi_R= pi_S$ is the fraction of people who would like to be tested because of symptoms of flu or cold among the population not infected with SARS-CoV-2. In models with several infected classes, this parameter can also be used to prioritise testing of patients with severe symptoms or elderly people . | The rate of positive tests in each class is computed as $$ tau_X= tau_{tot}(t) pi_X kappa_X/ mathcal{N} $$ for $X in {S,I,R }$ with the normalisation constant $$ mathcal{N}= sum_X pi_X X$$ . | . Next, we define the initial condition for all non-quarantined and quarantined states. $R$ is never specified but calculated from the total number. The initial value for $N^Q$ is specified for the auxiliary class NiQ. The (scalar) testing rate $ tau_{tot}(t)$ is specified as a Python function, similar to the time dependent contact matrix. Here, we specify a rapid increase from 10 to 100 tests per day around day 40. . M = 3 Ni = 1000*np.ones(M) N = np.sum(Ni) # Initial conditions as an array x0 = np.array([ 990, 990, 990, # S 10, 10, 10, # I 0, 0, 0, # SQ 0, 0, 0, # IQ 0, 0, 0, # NiQ ]) # Set up contact matrix CM = np.array([ [1, 0.5, 0.1], [0.5, 1, 0.5], [0.1, 0.5, 1 ] ], dtype=float) def contactMatrix(t): return CM # Tests performed per day def testRate(t): return (90.*(1.+np.tanh((t-40.)/10.))/2.+10.) # duration of simulation and data file Tf = 100; Nf=Tf+1; model = pyross.deterministic.SppQ(model_spec, parameters, M, Ni) # simulate model data = model.simulate(x0, contactMatrix, testRate, Tf, Nf) # non-quarantined version for comarpison model_specU = model_spec.copy() model_specU.pop(&#39;test_freq&#39;) model_specU.pop(&#39;test_pos&#39;) modelU = pyross.deterministic.Spp(model_specU, parameters, M, Ni) dataU = modelU.simulate(x0[0:(2*M)], contactMatrix, Tf, Nf) . # plot the data and obtain the epidemic curve S = np.sum(model.model_class_data(&#39;S&#39;, data), axis=1) I = np.sum(model.model_class_data(&#39;I&#39;, data), axis=1) R = np.sum(model.model_class_data(&#39;R&#39;, data), axis=1) SQ = np.sum(model.model_class_data(&#39;SQ&#39;, data), axis=1) IQ = np.sum(model.model_class_data(&#39;IQ&#39;, data), axis=1) RQ = np.sum(model.model_class_data(&#39;RQ&#39;, data), axis=1) NQ = np.sum(model.model_class_data(&#39;NiQ&#39;, data), axis=1) SU = np.sum(modelU.model_class_data(&#39;S&#39;, dataU), axis=1) IU = np.sum(modelU.model_class_data(&#39;I&#39;, dataU), axis=1) RU = np.sum(modelU.model_class_data(&#39;R&#39;, dataU), axis=1) t = data[&#39;t&#39;] fig = plt.figure(num=None, figsize=(16, 6), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;) plt.rcParams.update({&#39;font.size&#39;: 18}) plt.subplot(1, 2, 1) plt.plot(t, S, &#39;-&#39;, color=&quot;#348ABD&quot;, label=&#39;$S$&#39;, lw=3) plt.plot(t, I, &#39;-&#39;, color=&#39;#A60628&#39;, label=&#39;$I$&#39;, lw=3) plt.plot(t, R, &#39;-&#39;, color=&quot;dimgrey&quot;, label=&#39;$R$&#39;, lw=3) plt.plot(t, SU, &#39;--&#39;, color=&quot;#348ABD&quot;, label=&#39;$S$ (w/o $Q$)&#39;, lw=2) plt.plot(t, IU, &#39;--&#39;, color=&#39;#A60628&#39;, label=&#39;$I$ (w/o $Q$)&#39;, lw=2) plt.plot(t, RU, &#39;--&#39;, color=&quot;dimgrey&quot;, label=&#39;$R$ (w/o $Q$)&#39;, lw=2) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.ylabel(&#39;Compartment value&#39;) plt.xlabel(&#39;Days&#39;); plt.subplot(1, 2, 2) tm = t[1:]-0.5 plt.plot(tm, [testRate(tt) for tt in tm], &#39;-&#39;, color=&quot;darkgreen&quot;, label=&#39;daily total tests&#39;, lw=3) plt.plot(tm, np.diff(NQ), &#39;-&#39;, color=&quot;#348ABD&quot;, label=&#39;daily positive tests&#39;, lw=3) plt.plot(tm, np.diff(I+R+IQ+RQ), &#39;-&#39;, color=&quot;#A60628&quot;, label=&#39;true new cases&#39;, lw=3) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.ylabel(&#39;Compartment value&#39;) plt.xlabel(&#39;Days&#39;); . In this simple model, testing and quarantining has helped to eradicate the disease. It is interesting to evaluate how many infections have been confired anf how many have remained unconfirmed: . print(&quot;Confirmed cases:&quot;, int(RQ[-1])) print(&quot;Confirmed cases (incl. false positives):&quot;, int(NQ[-1])) print(&quot;Total cases:&quot;, int(R[-1]+RQ[-1])) . Confirmed cases: 208 Confirmed cases (incl. false positives): 265 Total cases: 495 . SEAIMR model: Reported infections and deaths . Let us now look at a more complicated model. We assume there is no contact tracing in place, therefore asymptomatic infecteds are tested as likely as susceptibles and recovereds. Fatal cases are assigned a 5 fold increased priority for testing compared to symptomatic cases. . model_spec = { &quot;classes&quot; : [&quot;S&quot;, &quot;E&quot;, &quot;A&quot;, &quot;Ia&quot;, &quot;Is&quot;, &quot;Im&quot;], &quot;S&quot; : { &quot;infection&quot; : [ [&quot;A&quot;, &quot;-beta&quot;], [&quot;Ia&quot;, &quot;-beta&quot;], [&quot;Is&quot;, &quot;-beta&quot;] ] }, &quot;E&quot; : { &quot;linear&quot; : [ [&quot;E&quot;, &quot;-gammaE&quot;] ], &quot;infection&quot; : [ [&quot;A&quot;, &quot;beta&quot;], [&quot;Ia&quot;, &quot;beta&quot;], [&quot;Is&quot;, &quot;beta&quot;] ] }, &quot;A&quot; : { &quot;linear&quot; : [ [&quot;E&quot;, &quot;gammaE&quot;], [&quot;A&quot;, &quot;-alphabar*gammaA&quot;], [&quot;A&quot;, &quot;-alpha*gammaA&quot;] ], &quot;infection&quot; : [ ] }, &quot;Ia&quot; : { &quot;linear&quot; : [ [&quot;A&quot;, &quot;alpha*gammaA&quot;], [&quot;Ia&quot;, &quot;-gammaIa&quot;] ], &quot;infection&quot; : [ ] }, &quot;Is&quot; : { &quot;linear&quot; : [ [&quot;A&quot;, &quot;alphabar*gammaA&quot;], [&quot;Is&quot;, &quot;-cfrbar*gammaIs&quot;], [&quot;Is&quot;, &quot;-cfr*gammaIs&quot;] ], &quot;infection&quot; : [ ] }, &quot;Im&quot; : { &quot;linear&quot; : [ [&quot;Is&quot;, &quot;cfr*gammaIs&quot;] ], &quot;infection&quot; : [ ] }, # S E A Ia Is Im R &quot;test_pos&quot; : [&quot;p_falsepos&quot;, &quot;p_trueposE&quot;, &quot;p_truepos&quot;, &quot;p_truepos&quot;, &quot;p_truepos&quot;, &quot;p_truepos&quot;, &quot;p_falsepos&quot;], &quot;test_freq&quot; : [&quot;pi_a&quot;, &quot;pi_a&quot;, &quot;pi_a&quot;, &quot;pi_a&quot;, &quot;pi_s&quot;, &quot;pi_m&quot;, &quot;pi_a&quot;] } alpha = 0.3 # fraction of asymptomatic cases beta = 0.4 #infection rate cfr = 0.01 # case fatality ratio gE = 0.04 # progression rate from E to A gA = 0.2 # progression rate from A to I gIa = 0.1 # removal rate of asymptomatic infectives gIs = 0.1 # removal rate of symptomatic infectives parameters = { &#39;beta&#39; : beta, &#39;gammaE&#39; : gE, &#39;alpha*gammaA&#39; : alpha*gA, &#39;alphabar*gammaA&#39; : (1-alpha)*gA, &#39;gammaIa&#39; : gIa, &#39;cfr*gammaIs&#39; : cfr*gIs, &#39;cfrbar*gammaIs&#39; : (1-cfr)*gIs, &#39;p_falsepos&#39; : 0.01, # probability of false positives &#39;p_truepos&#39; : 0.9, # probability of true positive for infecteds &#39;p_trueposE&#39; : 0.5, # probability of true positive for exposed &#39;pi_a&#39; : 0.05, # fraction of people with flu or cold &#39;pi_s&#39; : 1, # set to 1 for reference &#39;pi_m&#39; : 5 # priority for testing fatal cases } . M = 3 Ni = 10000*np.ones(M) N = np.sum(Ni) # Initial conditions as an array x0 = np.array([ 9990, 9990, 9990, # S 10, 10, 10, # E 0, 0, 0, # A 0, 0, 0, # Ia 0, 0, 0, # Is 0, 0, 0, # Im 0, 0, 0, # SQ 0, 0, 0, # EQ 0, 0, 0, # AQ 0, 0, 0, # IaQ 0, 0, 0, # IsQ 0, 0, 0, # ImQ 0, 0, 0, # NiQ ]) # Duration of simulation Tf = 160 # Tests performed per day def testRate(t): return (400.*(1.+np.tanh((t-40.)/10.))/2.+100.) model = pyross.deterministic.SppQ(model_spec, parameters, M, Ni) data = model.simulate(x0, contactMatrix, testRate, Tf, Nf) . # plot the data and obtain the epidemic curve S = np.sum(model.model_class_data(&#39;S&#39;, data), axis=1) E = np.sum(model.model_class_data(&#39;E&#39;, data), axis=1) A = np.sum(model.model_class_data(&#39;A&#39;, data), axis=1) Ia = np.sum(model.model_class_data(&#39;Ia&#39;, data), axis=1) Is = np.sum(model.model_class_data(&#39;Is&#39;, data), axis=1) Im = np.sum(model.model_class_data(&#39;Im&#39;, data), axis=1) R = np.sum(model.model_class_data(&#39;R&#39;, data), axis=1) SQ = np.sum(model.model_class_data(&#39;SQ&#39;, data), axis=1) EQ = np.sum(model.model_class_data(&#39;EQ&#39;, data), axis=1) AQ = np.sum(model.model_class_data(&#39;AQ&#39;, data), axis=1) IaQ = np.sum(model.model_class_data(&#39;IaQ&#39;, data), axis=1) IsQ = np.sum(model.model_class_data(&#39;IsQ&#39;, data), axis=1) ImQ = np.sum(model.model_class_data(&#39;ImQ&#39;, data), axis=1) RQ = np.sum(model.model_class_data(&#39;RQ&#39;, data), axis=1) NQ = np.sum(model.model_class_data(&#39;NiQ&#39;, data), axis=1) t = data[&#39;t&#39;] fig = plt.figure(num=None, figsize=(16, 12), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;) plt.rcParams.update({&#39;font.size&#39;: 18}) plt.subplot(2, 2, 1) plt.plot(t, S, &#39;-&#39;, color=&quot;#348ABD&quot;, label=&#39;$S$&#39;, lw=3) plt.plot(t, A+Ia+Is+Im, &#39;-&#39;, color=&#39;#A60628&#39;, label=&#39;$A+I$&#39;, lw=3) plt.plot(t, R, &#39;-&#39;, color=&quot;dimgrey&quot;, label=&#39;$R$&#39;, lw=3) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.ylabel(&#39;Compartment value&#39;) plt.xlabel(&#39;Days&#39;); plt.subplot(2, 2, 2) tm = t[1:]-0.5 plt.plot(tm, [testRate(tt) for tt in tm], &#39;-&#39;, color=&quot;darkgreen&quot;, label=&#39;daily total tests&#39;, lw=3) plt.plot(tm, np.diff(NQ), &#39;-&#39;, color=&quot;#348ABD&quot;, label=&#39;daily positive tests&#39;, lw=3) plt.plot(tm, - np.diff(S+SQ), &#39;-&#39;, color=&quot;#A60628&quot;, label=&#39;true new cases&#39;, lw=3) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.ylabel(&#39;Compartment value&#39;) plt.xlabel(&#39;Days&#39;); plt.subplot(2, 2, 3) plt.plot(t, ImQ, &#39;-&#39;, color=&quot;#348ABD&quot;, label=&#39;reported deaths&#39;, lw=3) plt.plot(t, Im+ImQ, &#39;--&#39;, color=&#39;#A60628&#39;, label=&#39;true deaths&#39;, lw=3) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.ylabel(&#39;Compartment value&#39;) plt.xlabel(&#39;Days&#39;); .",
            "url": "https://pyrosslib.github.io/blog/notebook/simulation/testing/2020/02/20/SppQ.html",
            "relUrl": "/notebook/simulation/testing/2020/02/20/SppQ.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Latent inference",
            "content": "%%capture ## compile PyRoss for this notebook import os owd = os.getcwd() os.chdir(&#39;../../&#39;) %run setup.py install os.chdir(owd) . %matplotlib inline import numpy as np import pyross import matplotlib.pyplot as plt #from matplotlib import rc; rc(&#39;text&#39;, usetex=True) . The SIR model with quarantine . Below you will find the model-specification dictionary for the SIR model with quarantined states . model_spec = { &quot;classes&quot; : [&quot;S&quot;, &quot;I&quot;], &quot;S&quot; : { &quot;infection&quot; : [ [&quot;I&quot;, &quot;-beta&quot;] ], }, &quot;I&quot; : { &quot;linear&quot; : [ [&quot;I&quot;, &quot;-gamma&quot;] ], &quot;infection&quot; : [ [&quot;I&quot;, &quot;beta&quot;] ], }, # S I R &quot;test_pos&quot; : [ &quot;p_falsepos&quot;, &quot;p_truepos&quot;, &quot;p_falsepos&quot;] , &quot;test_freq&quot; : [ &quot;pi_RS&quot;, &quot;pi_I&quot;, &quot;pi_RS&quot;] } parameters = { &#39;beta&#39; : 0.02, &#39;gamma&#39; : 0.1, &#39;p_falsepos&#39; : 0.01, &#39;p_truepos&#39; : 0.9, &#39;pi_RS&#39; : 0.1, &#39;pi_I&#39; : 1 } . This corresponds to . $$ begin{aligned} dot{S}_i &amp; = - beta sum_j C_{ij} frac{I_j}{N_j} S_i - tau_S S_i; &amp; dot{S}^Q_i &amp; = tau_S S_i dot{I}_i &amp; = beta sum_j C_{ij} frac{I_j}{N_j} S_i - gamma I_i - tau_I I_i; &amp; dot{I}^Q_i &amp; =- gamma I_i^Q+ tau_I I_i dot{R}_i &amp; = gamma I_i- tau_R R_i; &amp; dot{R}^Q_i &amp; = gamma I^Q_i+ tau_R R_i; end{aligned} $$Each of the classes, S, I and R, have a quarantined version, SQ, IQ and RQ. The dynamics within the quarantined states is the same as for the un-quarantined states, but there are no infection terms (assuming perfect quarantine). Individuals are quarantined upon testing positive, hence the total number $N^Q=S^Q+I^Q+R^Q$ would be the reported number of confirmed cases. . The transition rates $ tau_S$, $ tau_I$, $ tau_R$ for irreversible transitions to the quarantined states are dependent on time and on other variables. They are determined by the overall testing rate $ tau_{tot}(t)$ and the parameters specified in &quot;test_pos&quot; and &quot;test_prob&quot; (ordered such that they match to S, I and R). . &quot;test_pos&quot; specifies the probability $ kappa_S$, $ kappa_I$, $ kappa_R$ that a test performed on an individual of a given class is positive. For classes $R$ and $S$, this is the conditional probability of false positives, for class $I$ the conditional probability of a true positive . | &quot;test_freq&quot; characterises the frequency $ pi_S$, $ pi_I$, $ pi_R$ of tests in a given class. The absolute values of these values does not matter, only their relative magnitudes. If we consider symptomatic testing and set $ pi_I=1$, then $ pi_R= pi_S$ is the fraction of people who would like to be tested because of symptoms of flu or cold among the population not infected with SARS-CoV-2. In models with several infected classes, this parameter can also be used to prioritise testing of patients with severe symptoms or elderly people . | The rate of positive tests in each class is computed as $$ tau_X= tau_{tot}(t) pi_X kappa_X/ mathcal{N} $$ for $X in {S,I,R }$ with the normalisation constant $$ mathcal{N}= sum_X pi_X X$$ . | . Next, we define the initial condition for all non-quarantined and quarantined states. $R$ is never specified but calculated from the total number. The initial value for $N^Q$ is specified for the auxiliary class NiQ. The (scalar) testing rate $ tau_{tot}(t)$ is specified as a Python function, similar to the time dependent contact matrix. Here, we specify a rapid increase from 10 to 100 tests per day around day 40. . M = 2 # the population has two age groups N = 5e4 # and this is the total population # set the age structure fi = np.array([0.25, 0.75]) # fraction of population in age age group Ni = N*fi # set the contact structure CM = np.array([[18., 9.], [3., 12.]]) # Initial conditions as an array S0 = np.array([Ni[0]-10, Ni[1]-10]) I0 = np.array([10, 10]) x0 = np.array([ S0[0], S0[1], # S I0[0], I0[1], # I 0, 0, # SQ 0, 0, # IQ 0, 0 # NiQ ]) def contactMatrix(t): return CM # Tests performed per day def testRate(t): return (900.*(1.+np.tanh((t-30.)/10.))/2.+100.) # duration of simulation and data file Tf = 100; Nf=Tf+1; model = pyross.stochastic.SppQ(model_spec, parameters, M, Ni) data = model.simulate(x0, contactMatrix, testRate, Tf, Nf) data_array = data[&#39;X&#39;] det_model = pyross.deterministic.SppQ(model_spec, parameters, M, Ni) data_det = det_model.simulate(x0, contactMatrix, testRate, Tf, Nf) data_array_data = data_det[&#39;X&#39;] # non-quarantined version for comarpison model_specU = model_spec.copy() model_specU.pop(&#39;test_freq&#39;) model_specU.pop(&#39;test_pos&#39;) modelU = pyross.stochastic.Spp(model_specU, parameters, M, Ni) dataU = modelU.simulate(x0[0:(2*M)], contactMatrix, Tf, Nf) . # plot the data and obtain the epidemic curve S = np.sum(model.model_class_data(&#39;S&#39;, data), axis=1) I = np.sum(model.model_class_data(&#39;I&#39;, data), axis=1) R = np.sum(model.model_class_data(&#39;R&#39;, data), axis=1) SQ = np.sum(model.model_class_data(&#39;SQ&#39;, data), axis=1) IQ = np.sum(model.model_class_data(&#39;IQ&#39;, data), axis=1) RQ = np.sum(model.model_class_data(&#39;RQ&#39;, data), axis=1) NQ = np.sum(model.model_class_data(&#39;NiQ&#39;, data), axis=1) NQ_det = np.sum(det_model.model_class_data(&#39;NiQ&#39;, data_det), axis=1) SU = np.sum(modelU.model_class_data(&#39;S&#39;, dataU), axis=1) IU = np.sum(modelU.model_class_data(&#39;I&#39;, dataU), axis=1) RU = np.sum(modelU.model_class_data(&#39;R&#39;, dataU), axis=1) t = data[&#39;t&#39;] fig = plt.figure(num=None, figsize=(16, 6), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;) plt.rcParams.update({&#39;font.size&#39;: 18}) plt.subplot(1, 2, 1) plt.plot(t, S, &#39;-&#39;, color=&quot;#348ABD&quot;, label=&#39;$S$&#39;, lw=3) plt.plot(t, I, &#39;-&#39;, color=&#39;#A60628&#39;, label=&#39;$I$&#39;, lw=3) plt.plot(t, R, &#39;-&#39;, color=&quot;dimgrey&quot;, label=&#39;$R$&#39;, lw=3) plt.plot(t, SU, &#39;--&#39;, color=&quot;#348ABD&quot;, label=&#39;$S$ (w/o $Q$)&#39;, lw=2) plt.plot(t, IU, &#39;--&#39;, color=&#39;#A60628&#39;, label=&#39;$I$ (w/o $Q$)&#39;, lw=2) plt.plot(t, RU, &#39;--&#39;, color=&quot;dimgrey&quot;, label=&#39;$R$ (w/o $Q$)&#39;, lw=2) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.ylabel(&#39;Compartment value&#39;) plt.xlabel(&#39;Days&#39;); plt.subplot(1, 2, 2) tm = t[1:]-0.5 plt.plot(tm, [testRate(tt) for tt in tm], &#39;-&#39;, color=&quot;darkgreen&quot;, label=&#39;daily total tests&#39;, lw=3) plt.plot(tm, np.diff(NQ), &#39;-&#39;, color=&quot;#348ABD&quot;, label=&#39;daily positive tests&#39;, lw=3) plt.plot(tm, np.diff(NQ_det), &#39;--&#39;, color=&quot;#348ABD&quot;, label=&#39;daily positive tests (deterministic)&#39;, lw=2) plt.plot(tm, np.diff(I+R+IQ+RQ), &#39;-&#39;, color=&quot;#A60628&quot;, label=&#39;true new cases&#39;, lw=3) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.ylabel(&#39;Compartment value&#39;) plt.xlabel(&#39;Days&#39;); . In this simple model, testing and quarantining has helped to eradicate the disease. It is interesting to evaluate how many infections have been confired anf how many have remained unconfirmed: . print(&quot;Confirmed cases:&quot;, int(RQ[-1])) print(&quot;Confirmed cases (incl. false positives):&quot;, int(NQ[-1])) print(&quot;Total cases:&quot;, int(R[-1]+RQ[-1])) . Confirmed cases: 13794 Confirmed cases (incl. false positives): 13973 Total cases: 42859 . # load the data and rescale to intensive variables Tf_inference = 30 # truncate to only getting the first few datapoints Nf_inference = Tf_inference+1 x = (data_array[:Nf_inference]).astype(&#39;float&#39;)/N inference_parameters = parameters.copy() . # a filter that sums over all the diagnosed people for each age group fltr = np.kron([0, 0, 0, 0, 1],np.identity(M)) print(fltr) # Compare the deterministic trajectory and the stochastic trajectory with the same # initial conditions and parameters obs=np.einsum(&#39;ij,kj-&gt;ki&#39;, fltr, x) x0=x[0] # initialise the estimator estimator = pyross.inference.SppQ(model_spec, inference_parameters, testRate, M, fi, Omega=N, lyapunov_method=&#39;euler&#39;) # compute -log_p for the original (correct) parameters logp = estimator.minus_logp_red(inference_parameters, x0, obs, fltr, Tf_inference, contactMatrix) print(logp) . [[0. 0. 0. 0. 0. 0. 0. 0. 1. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]] 7340.618789800772 . # make parameter guesses and set up bounds for each parameter eps=1e-4 param_priors = { &#39;beta&#39;:{ &#39;mean&#39;: 0.015, &#39;std&#39;: 0.015, &#39;bounds&#39;: (eps, 0.1) }, &#39;gamma&#39;:{ &#39;mean&#39;: 0.08, &#39;std&#39;: 0.1, &#39;bounds&#39;: (eps, 1) } } # set up filter for initial conditions because they are constraint by the observed # note that this filter is different from the bulk of the trajectory, # because we know the initial value 0 holds for all quarantined age groups obs0 = np.zeros(M*3) fltr0 = np.kron(([[0, 0, 1, 0, 0],[0, 0, 0, 1, 0],[0, 0, 0, 0, 1]]), np.identity(M)) init_fltr = np.repeat([True, True, False, False, False], M) full_obs = np.array([obs0, *obs[1:]]) full_fltrs = np.array([fltr0, *([fltr]*(Nf_inference-1))]) I0_g = (I0)/N I_std = I0_g bounds_for_I = np.tile([0.1/N, 100/N], M).reshape(M, 2) S0_g = (S0)/N S_std = I_std*3 bounds_for_S = np.array([(1/N, f) for f in fi]) init_priors = { &#39;independent&#39;:{ &#39;fltr&#39;:np.repeat([True, True, False, False, False], M), &#39;mean&#39;:[*S0_g, *I0_g], &#39;std&#39;: [*S_std, *I_std], &#39;bounds&#39;: [*bounds_for_S, *bounds_for_I] } } # optimisation parameters ftol = 1e-5 # the relative tol in (-logp) res = estimator.latent_infer_parameters(full_obs, full_fltrs, Tf_inference, contactMatrix, param_priors, init_priors, global_max_iter=30, global_atol=10, verbose=True, ftol=ftol) . Starting global minimisation... (8_w,16)-aCMA-ES (mu_w=4.8,w_1=32%) in dimension 6 (seed=3525744721, Mon Jun 29 21:23:47 2020) Iterat #Fevals function value axis ratio sigma min&amp;max std t[m:s] 1 16 9.504797735285103e+03 1.0e+00 9.64e-01 2e-04 9e-02 0:02.3 2 32 1.037341923900685e+04 1.3e+00 9.69e-01 2e-04 9e-02 0:04.2 3 48 1.045076125197419e+04 1.6e+00 8.87e-01 2e-04 8e-02 0:06.0 5 80 7.773135473960824e+03 1.8e+00 9.25e-01 2e-04 9e-02 0:10.3 8 128 8.807839647141183e+03 2.3e+00 9.55e-01 2e-04 9e-02 0:15.6 11 176 6.979163233806639e+03 3.1e+00 7.05e-01 1e-04 6e-02 0:21.7 14 224 6.576161193964581e+03 4.8e+00 8.22e-01 1e-04 7e-02 0:28.2 18 288 6.467947809238211e+03 6.5e+00 6.32e-01 9e-05 5e-02 0:36.9 22 352 6.083612461091187e+03 7.3e+00 6.56e-01 8e-05 4e-02 0:45.2 27 432 6.006912670156744e+03 6.8e+00 7.14e-01 8e-05 4e-02 0:55.1 Optimal value (global minimisation): 5803.497303116372 Starting local minimisation... Optimal value (local minimisation): 5579.159205539509 . print(&quot;True parameters:&quot;) print(inference_parameters) print(&quot; nInferred parameters:&quot;) best_estimates = res[&#39;map_params_dict&#39;] print(best_estimates) print(&#39; n True initial conditions: &#39;) print((x0*N).astype(&#39;int&#39;)) map_x0 = res[&#39;map_x0&#39;] print(&#39; n Inferred initial conditons: &#39;) print((map_x0*N).astype(&#39;int&#39;)) # compute -log_p for the original (correct) parameters logp = estimator.minus_logp_red(inference_parameters, map_x0, obs, fltr, Tf_inference, contactMatrix) print(logp) . True parameters: {&#39;beta&#39;: 0.02, &#39;gamma&#39;: 0.1, &#39;p_falsepos&#39;: 0.01, &#39;p_truepos&#39;: 0.9, &#39;pi_RS&#39;: 0.1, &#39;pi_I&#39;: 1} Inferred parameters: {&#39;beta&#39;: 0.03165519834043866, &#39;gamma&#39;: 0.280704481148091, &#39;p_falsepos&#39;: array([0.01, 0.01]), &#39;p_truepos&#39;: array([0.9, 0.9]), &#39;pi_RS&#39;: array([0.1, 0.1]), &#39;pi_I&#39;: array([1., 1.])} True initial conditions: [12490 37490 10 10 0 0 0 0 0 0] Inferred initial conditons: [12477 37481 15 11 0 0 0 0 0 0] 6592.4847215358095 . # plot the guessed trajectory and the true trajectory estimator.set_params(best_estimates) estimator.set_det_model(best_estimates) x_det = estimator.integrate(map_x0, 0, Tf, Nf) fig = plt.figure(num=None, figsize=(10, 8), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;) plt.rcParams.update({&#39;font.size&#39;: 22}) plt.plot(S/N, label=&#39;True S&#39;, ls=&#39;--&#39;, c=&#39;C1&#39;) plt.plot(np.sum(x_det[:, 0*M:1*M],axis=1), label=&#39;Inferred S&#39;, c=&#39;C1&#39;) plt.plot(I/N, label=&#39;True I&#39;, ls=&#39;--&#39;, c=&#39;C2&#39;) plt.plot(np.sum(x_det[:, 1*M:2*M],axis=1), label=&#39;Inferred I&#39;, c=&#39;C2&#39;) plt.plot(NQ/N, label=&#39;True Q ($S^Q+I^Q+R^Q$)&#39;, ls=&#39;--&#39;, c=&#39;C3&#39;) plt.plot(np.sum(x_det[:, 4*M:5*M],axis=1), label=&#39;Inferred Q&#39;, c=&#39;C3&#39;) plt.axvspan(0, Tf_inference, label=&#39;Used for inference&#39;, alpha=0.3, color=&#39;dodgerblue&#39;) plt.xlim([0, Tf]) plt.legend(fontsize=18); plt.grid() plt.autoscale(enable=True, axis=&#39;x&#39;, tight=True) plt.xlabel(&quot;time [days]&quot;) plt.show() .",
            "url": "https://pyrosslib.github.io/blog/notebook/inference/testing/2020/02/19/SppQ_latent_inference.html",
            "relUrl": "/notebook/inference/testing/2020/02/19/SppQ_latent_inference.html",
            "date": " • Feb 19, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "PyRoss first blog post",
            "content": "PyRoss blog . This is the first post of the PyRoss blog .",
            "url": "https://pyrosslib.github.io/blog/news/2020/01/14/test-markdown-post.html",
            "relUrl": "/news/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "PyRoss is a numerical library that offers an integrated platform for inference, forecasts and non-pharmaceutical interventions in structured epidemiological compartment models. . Compartment models of arbitrary complexity can be user-defined through Python dictionaries. The most common epidemiological models, and several less common ones, come pre-defined with the library. Models can include stages to allow for non-exponentially distributed compartmental residence times. Currently, pre-defined models include ones with multiple disease states (exposed, asymptomatic, symptomatic, etc) and may be further divided by age, and by objective medical states (hospitalized, in ICU, etc). The compartment framework supports models for disease surveillance and quarantine and a variety of other processes of epidemiological relevance. . Generative processes can be formulated stochastically (as Markov population processes) or deterministically (as systems of differential equations). Population processes are sampled exactly by the Doob-Gillespie algorithm or approximately by the tau-leaping algorithm while differential equations are integrated by both fixed and adaptive time-stepping. A hybrid algorithm transits dynamically between these depending on the magnitude of the compartmental fluctuations. . Bayesian inference on pre-defined or user-defined models is performed using model-adapted Gaussian processes derived from functional limit theorems for Markov population process. Generative models are fitted to data through the surveillance model allowing for possibily unobserved compartments. The MAP estimates of parameters and their standard errors can be obtained rapidly by optimising, obviating the need for expensive Markov chain Monte Carlo. This enables the fast evaluation of the model evidence, through which competing models may be objectively compared and their forecasts combined by Bayesian model averaging. Forecasts of disease progression, then, can be fully Bayesian, convolving uncertainties in data, parameters and models. The sensitivity of these forecasts is estimated through the Fisher information matrix. . Non-pharmaceutical interventions are implemented as modifications of the contact structures of the model. Optimised control of these structures, given cost functions, is possible. This feature is being actively developed to be better integrated with the library. . PyRossGeo is a companion library that supports spatially resolved compartment models with explicit commuting networks. PyRossTSI is another companion library for time since infection models. . The libraries are named after Sir Ronald Ross, doctor, mathematician and poet. In 1898 he made “the great discovery” in his laboratory in Calcutta “that malaria is conveyed by the bite of a mosquito”. He won the Nobel Prize in 1902 and laid the foundations of the mathematical modelling of infectious diseases. . The authors are part of The Rapid Assistance in Modelling the Pandemic (RAMP) taskforce at the University of Cambridge. In alphabetical order, we are: Ronojoy Adhikari, Austen Bolitho, Fernando Caballero, Michael Cates, Jakub Dolezal, Tim Ekeh, Jules Guioth, Robert Jack, Julian Kappler, Lukas Kikuchi, Irene Li, Joseph Peterson, Patrick Pietzonka, Benjamin Remez, Paul Rohrbach, Rajesh Singh, and Günther Turk. . Please read the PyRoss paper and PyRoss Wiki before you use PyRoss for your research. Open an issue, in preference to emailing us with queries. Join our Slack channel for discussion. Please follow the Contributor Covenant in all PyRoss fora. Thank you! .",
          "url": "https://pyrosslib.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://pyrosslib.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}